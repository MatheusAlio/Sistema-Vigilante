import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk, ImageDraw
import cv2
import threading
import socket
import subprocess
import queue
import time
import requests
import json
import os

      # ==============================
      # CONFIGURAÇÃO DE ARDUINOS E PÂNICO
      # ==============================
CONFIG_FILE = "config.json"

      # NÚMERO DE PORTAS ATIVAS FOI MUDADO DE 4 PARA 8 AQUI
NUM_PORTAS_PANICO = 8 

CONFIG_PADRAO = {
    "arduinos": {str(i): f"192.168.150.{40+i}" for i in range(1, 9)},
    "portas_arduino": {str(i): [True, True, True, True] for i in range(1, 9)},
    "panicos": {str(i): f"192.168.150.{50+i}" for i in range(1, 9)},
    # ATUALIZADO: Inicializa com 8 portas para Pânico Geral
    "portas_panico": {str(i): [True] * NUM_PORTAS_PANICO for i in range(1, 9)}
}

def carregar_config():
    if not os.path.exists(CONFIG_FILE):
        salvar_config(CONFIG_PADRAO)
        return CONFIG_PADRAO
    try:
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            conteudo = f.read().strip()
            if not conteudo:
                raise ValueError("Arquivo vazio")
            
            config = json.loads(conteudo)
            
            # Garante que portas_panico tenha 8 elementos, preenchendo com False se faltar
            for i in range(1, 9):
                key = str(i)
                current_ports = config.get("portas_panico", {}).get(key, [])
                if len(current_ports) < NUM_PORTAS_PANICO:
                    current_ports.extend([False] * (NUM_PORTAS_PANICO - len(current_ports)))
                config["portas_panico"][key] = current_ports
                
            return config
            
    except Exception as e:
        print(f"[ERRO] Falha ao carregar config.json: {e}")
        salvar_config(CONFIG_PADRAO)
        return CONFIG_PADRAO

def salvar_config(novo_config):
    try:
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(novo_config, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"[ERRO] Falha ao salvar config.json: {e}")

CONFIG = carregar_config()

          # ==============================
          # FUNÇÕES AUXILIARES
          # ==============================
def aplicar_hover(botao, cor_normal, cor_hover):
    botao.bind("<Enter>", lambda e: botao.config(bg=cor_hover))
    botao.bind("<Leave>", lambda e: botao.config(bg=cor_normal))

def pegar_ip_local():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "192.168.0.100"

def testar_ping(ip):
    try:
        resultado = subprocess.run(
            ["ping", "-n" if subprocess.os.name == "nt" else "-c", "1", ip],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        return resultado.returncode == 0
    except Exception:
        return False

          # ==============================
          # CAMERA VIEWER
          # ==============================
class CameraViewer:
    def __init__(self, janela, rtsp_url, display_size=(640,360), delay_ms=200):
        self.janela = janela
        self.url = rtsp_url
        self.display_width, self.display_height = display_size
        self.delay = delay_ms
        self.label_video = tk.Label(self.janela, bg="black")
        self.label_video.pack(fill=tk.BOTH, expand=True)
        self.frame_queue = queue.Queue(maxsize=2)
        self.running = True
        self.connected = False
        self.cap = None
        threading.Thread(target=self._capture_loop, daemon=True).start()
        self._update_display()
        self.janela.protocol("WM_DELETE_WINDOW", self.fechar)

    def _open_capture(self):
        try:
            if self.cap: self.cap.release()
            self.cap = cv2.VideoCapture(self.url, cv2.CAP_FFMPEG)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.display_width)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.display_height)
        except Exception:
            self.cap = None

    def _capture_loop(self):
        while self.running:
            if not self.cap or not getattr(self.cap,"isOpened",lambda:False)():
                self.connected = False
                self._open_capture()
                time.sleep(1)
                continue
            ret, frame = self.cap.read()
            if ret and frame is not None:
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame = cv2.resize(frame, (self.display_width, self.display_height))
                if self.frame_queue.full(): self.frame_queue.get_nowait()
                self.frame_queue.put_nowait(frame)
                self.connected = True
            else:
                self.connected = False
                time.sleep(0.2)
        if self.cap: self.cap.release()

    def _placeholder_no_signal(self):
        img = Image.new("RGB", (self.display_width, self.display_height), (0,0,0))
        draw = ImageDraw.Draw(img)
        draw.text((10,10),"SEM SINAL",(255,0,0))
        return img

    def _update_display(self):
        if not self.running: return
        try:
            frame = None
            while True:
                try: frame = self.frame_queue.get_nowait()
                except queue.Empty: break
            img = Image.fromarray(frame) if frame is not None else self._placeholder_no_signal()
        except Exception:
            img = self._placeholder_no_signal()
        imgtk = ImageTk.PhotoImage(img)
        self.label_video.imgtk = imgtk
        self.label_video.config(image=imgtk)
        self.janela.after(self.delay, self._update_display)

    def fechar(self):
        self.running = False
        if self.cap: self.cap.release()
        try: self.janela.destroy()
        except Exception: pass

           # ==============================
           # GUI DE CONFIGURAÇÃO
           # ==============================
class ConfiguracoesGerais(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Configurações Arduino e Pânico")
        self.configure(bg="#2C2F44")
        self.resizable(True, True)

        # Estruturas de armazenamento
        self.arduinos = {}        # {i: {"entry": Entry, "portas": [IntVar,...]}}
        self.panicos = {}
        self.panicos_geral = {}
        
        # Cria um Frame com scrollbar para o conteúdo
        self.canvas = tk.Canvas(self, bg="#2C2F44", highlightthickness=0)
        self.canvas.pack(side="top", fill="both", expand=True)
        
        self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollbar.pack(side="right", fill="y")
        
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        self.scrollable_frame = tk.Frame(self.canvas, bg="#2C2F44")
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        # Bind do evento de scroll do mouse (roda do mouse)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        

        # Cabeçalho
        tk.Label(self.scrollable_frame, text="Configurações de Arduinos e Pânicos",
                 bg="#2C2F44", fg="white", font=("Arial", 14, "bold")).pack(pady=10)

        # Frame principal para blocos
        main_frame = tk.Frame(self.scrollable_frame, bg="#2C2F44")
        main_frame.pack(padx=10, pady=10)

        # Criar blocos 4x2 (Arduino + Pânico)
        for idx in range(8):
            linha = idx // 4
            coluna = idx % 4
            self.criar_bloco(main_frame, idx+1, linha, coluna)

        # --- BLOCO DE PÂNICO GERAL ---
        self.criar_bloco_panico_geral(self.scrollable_frame)

        # Botões
        btn_frame = tk.Frame(self.scrollable_frame, bg="#2C2F44")
        btn_frame.pack(pady=10)
        tk.Button(btn_frame, text="Testar Conexões", bg="#2196F3", fg="white", width=18,
                  command=self.testar_conexoes).pack(side="left", padx=10)
        tk.Button(btn_frame, text="Salvar Configurações", bg="#4CAF50", fg="white", width=22,
                  command=self.salvar_tudo).pack(side="left", padx=10)
        tk.Button(btn_frame, text="Fechar", bg="#F44336", fg="white", width=15,
                  command=self.destroy).pack(side="left", padx=10)

          # Adiciona a função de scroll
    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
          # ===============================
          # Criar bloco individual Arduino+Pânico
          # ===============================
    def criar_bloco(self, parent, i, linha, coluna):
        bloco = tk.Frame(parent, bg="#2C2F44", bd=2, relief="groove", padx=5, pady=5)
        bloco.grid(row=linha, column=coluna, padx=5, pady=5, sticky="n")

        # --- Arduino ---
        tk.Label(bloco, text=f"Arduino {i}", bg="#2C2F44", fg="white", font=("Arial", 12, "bold")).pack(anchor="w", pady=2)
        tk.Label(bloco, text="IP Arduino:", bg="#2C2F44", fg="white").pack(anchor="w")
        entry_a = tk.Entry(bloco, width=15)
        entry_a.insert(0, CONFIG["arduinos"].get(str(i), ""))
        entry_a.pack(anchor="w", pady=2)

        tk.Label(bloco, text="Portas Ativas:", bg="#2C2F44", fg="white").pack(anchor="w")
        frame_portas = tk.Frame(bloco, bg="#2C2F44")
        frame_portas.pack(anchor="w", pady=2)

        portas_config = CONFIG.get("portas_arduino", {}).get(str(i), [True]*4)
        check_vars = []
        for p in range(4): # Mantém 4 portas para os Arduinos individuais
            var = tk.IntVar(value=1 if portas_config[p] else 0)
            cb = tk.Checkbutton(frame_portas, text=f"P{p+1}", variable=var,
                                 bg="#2C2F44", fg="white", selectcolor="#4CAF50",
                                 activebackground="#2C2F44", activeforeground="white")
            cb.pack(side="left", padx=2)
            check_vars.append(var)

        self.arduinos[i] = {"entry": entry_a, "portas": check_vars}

        # --- Pânico ---
        tk.Label(bloco, text=f"Pânico {i}", bg="#2C2F44", fg="white", font=("Arial", 12, "bold")).pack(anchor="w", pady=(10,2))
        tk.Label(bloco, text="IP Pânico:", bg="#2C2F44", fg="white").pack(anchor="w")
        entry_p = tk.Entry(bloco, width=15)
        entry_p.insert(0, CONFIG["panicos"].get(str(i), ""))
        entry_p.pack(anchor="w", pady=2)

        # Mantém 4 portas para os Pânicos individuais (Portas Ativas)
        portas_panico_config = CONFIG.get("portas_panico", {}).get(str(i), [True]*NUM_PORTAS_PANICO)[:4] 
        check_vars_p = []
        tk.Label(bloco, text="Portas Ativas:", bg="#2C2F44", fg="white").pack(anchor="w")
        frame_portas_p = tk.Frame(bloco, bg="#2C2F44")
        frame_portas_p.pack(anchor="w", pady=2)
        for p in range(4):
            var = tk.IntVar(value=1 if portas_panico_config[p] else 0)
            cb = tk.Checkbutton(frame_portas_p, text=f"P{p+1}", variable=var,
                                 bg="#2C2F44", fg="white", selectcolor="#4CAF50",
                                 activebackground="#2C2F44", activeforeground="white")
            cb.pack(side="left", padx=2)
            check_vars_p.append(var)

        self.panicos[i] = {"entry": entry_p, "portas": check_vars_p}


           # ===============================
           # Novo bloco: PÂNICO GERAL
           # ===============================
    def criar_bloco_panico_geral(self, parent):
        frame_geral = tk.Frame(parent, bg="#2C2F44", bd=2, relief="groove", padx=10, pady=10)
        frame_geral.pack(padx=10, pady=10, fill="x")

        tk.Label(frame_geral, text="PÂNICO GERAL", bg="#2C2F44", fg="white",
                  font=("Arial", 14, "bold")).pack(anchor="w", pady=(0, 10))

        self.panicos_geral = {}

        for i in range(1, 9):
            linha = tk.Frame(frame_geral, bg="#2C2F44")
            linha.pack(anchor="w", pady=3, fill="x")

            tk.Label(linha, text=f"IP Pânico {i}:", bg="#2C2F44", fg="white", width=10, anchor="w").pack(side="left", padx=5)
            entry = tk.Entry(linha, width=15)
            entry.insert(0, CONFIG["panicos"].get(str(i), ""))
            entry.pack(side="left", padx=5)

            tk.Label(linha, text="Portas Ativas:", bg="#2C2F44", fg="white").pack(side="left", padx=(15, 5))
            
            check_vars = []
            # LÓGICA ATUALIZADA: Cria 8 checkbuttons
            portas_cfg = CONFIG.get("portas_panico", {}).get(str(i), [True] * NUM_PORTAS_PANICO)
            for p in range(NUM_PORTAS_PANICO): 
                var = tk.IntVar(value=1 if portas_cfg[p] else 0)
                cb = tk.Checkbutton(linha, text=f"P{p+1}", variable=var,
                                     bg="#2C2F44", fg="white", selectcolor="#4CAF50",
                                     activebackground="#2C2F44", activeforeground="white")
                cb.pack(side="left", padx=1)
                check_vars.append(var)

            self.panicos_geral[i] = {"entry": entry, "portas": check_vars}

              # -------------------------------
              # Funções internas
              # -------------------------------
    def testar_conexoes(self):
        # ... (Mantém a lógica de teste de conexões inalterada, focando apenas nos IPs)
        resultados = []
        for i in range(1, 9):
              ip_a = self.arduinos[i]["entry"].get().strip()
              ip_p = self.panicos[i]["entry"].get().strip()
              try:
                  r = requests.get(f"http://{ip_a}", timeout=1)
                  resultados.append(f"Arduino {i}: {'✅ OK' if r.status_code == 200 else f'⚠️ Erro {r.status_code}'}")
              except Exception:
                  resultados.append(f"Arduino {i}: ❌ Falha")
              try:
                  # Usa o IP da seção Pânico Geral para teste, se for o caso.
                  ip_geral = self.panicos_geral[i]["entry"].get().strip()
                  r = requests.get(f"http://{ip_geral}", timeout=1)
                  resultados.append(f"Pânico {i} (Geral): {'✅ OK' if r.status_code == 200 else f'⚠️ Erro {r.status_code}'}")
              except Exception:
                  resultados.append(f"Pânico {i} (Geral): ❌ Falha")
        messagebox.showinfo("Teste de Conexões", "\n".join(resultados))

    def salvar_tudo(self):
        novas_config = {"arduinos": {}, "portas_arduino": {}, "panicos": {}, "portas_panico": {}}

        # Arduino + Pânico (blocos menores) - As portas Pânico aqui têm apenas 4.
        for i in range(1, 9):
            novas_config["arduinos"][str(i)] = self.arduinos[i]["entry"].get().strip()
            novas_config["portas_arduino"][str(i)] = [bool(var.get()) for var in self.arduinos[i]["portas"]]

            # Guarda os primeiros 4 valores, se for o caso, ou usa os do bloco geral mais abaixo
            # Por simplicidade, vamos usar os valores do Pânico Geral para o dicionário panicos/portas_panico.
            pass 

        # Pânico Geral (Bloco grande) - SALVA O IP e as 8 PORTAS
        for i in range(1, 9):
            # O IP da linha PÂNICO GERAL é usado como IP de PÂNICO
            novas_config["panicos"][str(i)] = self.panicos_geral[i]["entry"].get().strip() 
            # ATUALIZADO: Salva o estado de 8 portas (P1 a P8)
            novas_config["portas_panico"][str(i)] = [bool(var.get()) for var in self.panicos_geral[i]["portas"]] 

        salvar_config(novas_config)
        messagebox.showinfo("Salvar", "Configurações salvas com sucesso!")

           # ==============================
           # CLASSE PRINCIPAL DE PORTÕES
           # ==============================
class TelaControlePortoes:
    def __init__(self, master):
        self.janela = master
        self.janela.title("Controle de Portões")
        self.janela.geometry("700x550") # Aumentado o tamanho para o novo status
        self.janela.configure(bg="#282A36")
        self.janela.resizable(False, False)
        self.status_portoes = {i:"Fechado" for i in range(1,9)}
        self.panico_ativo = False
        # Recarrega a configuração para garantir que tem o dado de 8 portas
        global CONFIG
        CONFIG = carregar_config()
        self.arduino_ips = {i: CONFIG["arduinos"].get(str(i)) for i in range(1,9)}

        # Aqui substituímos pelo seu código de IPs personalizados
        ips = ["192.168.150.179", "192.168.150.178", "192.168.150.177",
               "192.168.150.176", "192.168.150.112", "192.168.150.113",
               "192.168.150.114", "192.168.150.115"]
        self.urls_cameras = {i+1: f"rtsp://admin:condo.54@{ip}:554/" for i, ip in enumerate(ips)}

        tk.Label(self.janela,text="Controle de 8 Portões",font=("Arial",16,"bold"),fg="white",bg="#282A36").pack(pady=10)
        frame_botoes = tk.Frame(self.janela,bg="#282A36")
        frame_botoes.pack(pady=20)

        self.btns_portoes = {}
        for i in range(1,9):
            btn = tk.Button(frame_botoes,text=f"Portão {i}",width=14,height=2,bg="#FF9800",fg="white",
                             font=("Arial",11,"bold"),command=lambda n=i:self.abrir_status_portao(n))
            btn.grid(row=(i-1)//4,column=(i-1)%4,padx=10,pady=10)
            aplicar_hover(btn,"#FF9800","#4CAF50")
            self.btns_portoes[i] = btn

        # NOVO: Status do Pânico Geral
        self.lbl_panico_status = tk.Label(self.janela, text="STATUS: Inativo", font=("Arial", 12, "bold"), 
                                         fg="white", bg="#282A36")
        self.lbl_panico_status.pack(pady=(0, 10))

        self.btn_panico = tk.Button(self.janela,text="Pânico Geral",width=15,height=2,bg="#FF0000",fg="white",
                                     font=("Arial",12,"bold"),command=self.enviar_panico_geral)
        self.btn_panico.pack(pady=20)

        barra_inferior = tk.Frame(self.janela,bg="#282A36")
        barra_inferior.pack(side=tk.BOTTOM,fill=tk.X)
        self.status_bar = tk.Label(barra_inferior,text=f"IP do computador: {pegar_ip_local()}",font=("Arial",10),fg="white",bg="#282A36")
        self.status_bar.pack(side=tk.RIGHT,padx=10,pady=5)

        self.btn_config = tk.Button(barra_inferior,text="Configuração",width=15,height=2,bg="#FF9800",fg="white",
                                     font=("Arial",6),command=self.abrir_configuracoes)
        self.btn_config.pack(side=tk.RIGHT,padx=10)

          # ==============================
          # FUNÇÃO DE PORTÕES
          # ==============================
    def enviar_comando_portao(self, numero_portao):
        ip = self.arduino_ips.get(numero_portao)
        try:
            # Carrega a configuração mais recente
            with open("config.json", "r", encoding="utf-8") as f:
                config = json.load(f)

            # Verifica quais portas estão ativas para esse Arduino
            portas_ativas = config.get("portas_arduino", {}).get(str(numero_portao), [True, True, True, True])

            # Envia o comando apenas para as portas ativas
            for i, ativa in enumerate(portas_ativas, start=1):
                if ativa:
                    url = f"http://{ip}/comando?portao={numero_portao}&porta={i}"
                    r = requests.get(url, timeout=5)
                    if r.status_code != 200:
                        raise Exception(f"Status {r.status_code} (porta {i})")

            # Atualiza status na interface
            self.status_portoes[numero_portao] = (
                "Aberto" if self.status_portoes[numero_portao] == "Fechado" else "Fechado"
            )
            # self.atualizar_status_botao(numero_portao) # Funcao comentada no original

        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao enviar comando para portão {numero_portao}: {e}")


          # ==============================
          # FUNÇÕES DE PÂNICO (AGORA COM THREADING)
          # ==============================
    def enviar_panico_geral(self):
        """Prepara e inicia a execução do Pânico Geral em uma thread separada, fornecendo feedback imediato."""
        
        if self.panico_ativo:
            messagebox.showwarning("Atenção", "O Pânico Geral já está em execução!")
            return
            
        # 1. Feedback imediato na GUI (Pânico Ativado)
        self.panico_ativo = True
        self.btn_panico.config(text="ATIVADO (EM CURSO)", bg="#FF4500", state=tk.DISABLED)
        self.lbl_panico_status.config(text="STATUS: PÂNICO ATIVADO", fg="#FF4500")

        # 2. Inicia a comunicação em uma thread separada para não travar a GUI
        threading.Thread(target=self._executar_panico_geral, daemon=True).start()

    def _executar_panico_geral(self):
        """Contém a lógica de comunicação de rede (executada em thread de background)."""
        resultados = []
        try:
            # Carrega a config dentro da thread para garantir a mais recente
            with open("config.json", "r", encoding="utf-8") as f:
                config = json.load(f)
        except Exception:
            resultados.append("❌ ERRO: Falha ao ler config.json.")
            # Retorna para a thread principal para atualizar a GUI
            self.janela.after(0, self._finalizar_panico_geral_gui, resultados)
            return

        panicos = config.get("panicos", {})
        portas_panico = config.get("portas_panico", {})

        for i in range(1, 9):
            ip = panicos.get(str(i), "").strip()
            if not ip:
                resultados.append(f"Pânico {i}: ⚠️ Sem IP configurado")
                continue

            # Obtém as 8 portas configuradas para o Pânico Geral
            portas = portas_panico.get(str(i), [False] * NUM_PORTAS_PANICO) 
            
            sucesso_bloco = False
            for idx, ativo in enumerate(portas):
                if ativo:
                    try:
                        # Comando para o Arduino: Mantido o formato original do usuário
                        url = f"http://{ip}/comando?portao={idx+1}" 
                        r = requests.get(url, timeout=2) # Aumentado o timeout para 2s
                        
                        if r.status_code == 200:
                            resultados.append(f"Pânico {i} Porta P{idx+1}: ✅ OK")
                            sucesso_bloco = True
                        else:
                            resultados.append(f"Pânico {i} Porta P{idx+1}: ❌ ERRO (Status {r.status_code})")
                    except requests.exceptions.Timeout:
                        resultados.append(f"Pânico {i} Porta P{idx+1}: ❌ TIMEOUT (2s)")
                    except Exception as e:
                        # Captura o nome da exceção para um relatório mais limpo
                        resultados.append(f"Pânico {i} Porta P{idx+1}: ❌ Falha na conexão ({type(e).__name__})")
            
            # Se não houve sucesso em nenhuma porta, adiciona uma mensagem geral
            if not sucesso_bloco and any(portas):
                 # Mensagem mais informativa se houver portas ativas mas todas falharem
                 resultados.append(f"Pânico {i}: ⚠️ Falha total no bloco (IP: {ip}).")
            elif not any(portas):
                 resultados.append(f"Pânico {i}: ℹ️ Nenhuma porta ativa para este dispositivo.")


        # 3. Retorna os resultados para a thread principal (GUI)
        # O método .after(0,...) garante que a função seja executada na thread do Tkinter
        self.janela.after(0, self._finalizar_panico_geral_gui, resultados)

    def _finalizar_panico_geral_gui(self, resultados):
        """Atualiza a GUI com os resultados (executada na thread principal)."""
        # 1. Reabilita e reseta o botão
        self.panico_ativo = False
        self.btn_panico.config(text="Pânico Geral", bg="#FF0000", state=tk.NORMAL)
        self.lbl_panico_status.config(text="STATUS: Inativo", fg="white")
        
        # 2. Exibe o relatório detalhado de status
        messagebox.showinfo("Relatório de Pânico Geral", "Sequência de Pânico Finalizada.\n\n" + "\n".join(resultados))

              # ==============================
              # OUTRAS FUNÇÕES
              # ==============================
    def abrir_status_portao(self, numero_portao):
        status = self.status_portoes[numero_portao]
        ip_portao = self.arduino_ips[numero_portao]
        janela = tk.Toplevel(self.janela)
        janela.title(f"Portão {numero_portao}")
        janela.geometry("450x200")
        janela.configure(bg="#282A36")

        tk.Label(janela,text=f"Portão {numero_portao} - Status: {status}",font=("Arial",14,"bold"),fg="white",bg="#282A36").pack(pady=15)
        frame_buttons = tk.Frame(janela,bg="#282A36")
        frame_buttons.pack(pady=20)

        btn_abrir = tk.Button(frame_buttons, text="Abrir/Fechar", bg="#FF9800", fg="white",
                              font=("Arial", 12, "bold"), width=12,
                              command=lambda n=numero_portao: self.enviar_comando_portao(n))
        btn_abrir.grid(row=0,column=0,padx=10)
        tk.Button(frame_buttons,text="Ver Câmera",bg="#2196F3",fg="white",font=("Arial",12,"bold"),width=12,
                  command=lambda:self.ver_camera(numero_portao)).grid(row=0,column=1,padx=10)
        tk.Button(frame_buttons,text="OK",bg="#4CAF50",fg="white",font=("Arial",12,"bold"),width=12,
                  command=janela.destroy).grid(row=0,column=2,padx=10)

        barra_inf = tk.Frame(janela,bg="#C0C0C0")
        barra_inf.pack(side=tk.BOTTOM,fill=tk.X)
        tk.Label(barra_inf,text=f"IP do Portão: {ip_portao}",font=("Arial",10),bg="#C0C0C0").pack(side=tk.RIGHT,padx=10)

    def ver_camera(self, numero_portao):
        rtsp = self.urls_cameras.get(numero_portao)
        if not rtsp:
            messagebox.showerror("Erro","Câmera não configurada!")
            return
        nova_janela = tk.Toplevel(self.janela)
        nova_janela.title(f"Câmera Portão {numero_portao}")
        nova_janela.geometry("640x360")
        CameraViewer(nova_janela,rtsp,display_size=(640,360),delay_ms=200)

    def abrir_configuracoes(self):
        ConfiguracoesGerais(self.janela)

        # ==============================
        # INICIALIZAÇÃO 
        # ==============================
if __name__ == "__main__":
    root = tk.Tk()
    app = TelaControlePortoes(root)
    root.mainloop()
